Constants = {}
Vars = {}
Intrinsics = {}
Libs = {}
Theme = {}
Console = {}
Conditions = {}

Sessions = []
ISessions = {}

Helps = {}
Aliases = {}
Commands = {}

Constants = {
    // 
    // Password is sha256() iterated 25 times
    // This string represents the "marinette" string
    // You are free to change this. And don't reveal it that easily :)
    "password": "27d518c314eec63e57fab0dc420c70d2d4657b3419cda980e7cdb827cc500be5",
    // 
    // Identificator is a signal that lets Marinette find itself in path.
    // You might want to change that if you are PVPing against another player
    // with Marinette, or if you and another player are hacking the same server.
    "identificator": "MUVNFRJCWETFBCAIPFIZERWJOMPKZYJC",
}


// 
// Vars are something that is set at runtime and used globally
// Don't touch unless you know what you are doing
Vars = {
    "password": null,
    "hostSession": null,
}


// 
// Shell objects that are used in commands
Intrinsics = {
    "shell": get_shell,
    "computer": get_shell.host_computer,
    "file": get_shell.host_computer.File("/"),
    "publicAddress": null,
    "localAddress": null,
    "port": null,
    "isConnectionRemote": false,
}


// 
// Color palletes used are here https://colorhunt.co
Theme = {
    "asciiArt": [
        "Oo      oO                                                 ",
        "O O    o o               o                                 ",
        "o  o  O  O                                 O     O         ",
        "O   Oo   O                                oOo   oOo        ",
        "O        o .oOoO' `OoOo. O  'OoOo. .oOo.   o     o   .oOo. ",
        "o        O O   o   o     o   o   O OooO'   O     O   OooO' ",
        "o        O o   O   O     O   O   o O       o     o   O     ",
        "O        o `OoO'o  o     o'  o   O `OoO'   `oO   `oO `OoO' ",
        "==========================================================",
    ],
    "ascii": "#DCBFFF",
    "asciiShadow": "#D0A2F7",
    "prefix": "#E5D4FF",
    "log": "#D0A2F7",
    "warning": "#FFECEC",
    "error": "#FF78C4",
    "inputMessage": "#D0A2F7",
    "input": "#DCBFFF",
    "miscPrimary": "#D0A2F7",
    "miscSecondary": "#DCBFFF",
}


Console.asciiArt = function
    art = Theme.asciiArt
    i = 0; while i < art.len; i = i + 1
        if i < round(art.len / 1.8) then
            print("<color="+Theme.ascii+">"+art[i-1])
        else
            print("<color="+Theme.asciiShadow+">"+art[i-1])
        end if
    end while
end function

Console._printWithColorAndTime = function(color, message=" ")
    currentTime = current_date.split(" - ")[1]
    print("<color="+Theme.prefix+">-"+currentTime+"- <color="+color+">"+message)
end function

Console.log = function(message=" ")
    Console._printWithColorAndTime(Theme.log, message)
end function

Console.warning = function(message=" ")
    Console._printWithColorAndTime(Theme.warning, message)
end function

Console.error = function(message=" ")
    Console._printWithColorAndTime(Theme.error, message)
end function

Console.input = function(message=" ")
    input = user_input("<color="+Theme.inputMessage+">"+message+"<color="+Theme.input+">")
    if isInputValid(input) then return input
    return ""
end function

Console.prompt = function
    fd = Intrinsics.file
    user = checkPermissions(fd)
    object = "Host"
    locIp = Intrinsics.localAddress

    if Intrinsics.isConnectionRemote then
        if Intrinsics.file then object = "File"
        if Intrinsics.computer then object = "Computer"
        if Intrinsics.shell then
            type = typeof(Intrinsics.shell)
            if type == "shell" then
                object = "Shell"
            else if type == "ftpshell" then
                object = "FtpShell"
            else
                object = "UnknownShell"
            end if
        end if
    end if

    if not locIp then locIp = "LocalHost"

    msg = Theme.inputMessage
    inp = Theme.input
    lines = [
        " <color="+msg+"> <b>"+user+"</b> as <b>"+object+"</b> on <b>"+locIp+"</b> in <b>"+fd.path,
        "<color="+msg+">% <color="+inp+">",
    ]
    return lines.join(char(10))
end function

Console.cmdloop = function
    while true
        input = Console.input(Console.prompt).trim
        if input.len == 0 then continue

        parts = input.split(" ")

        command = parts.pull
        if Commands.indexes.indexOf(command) == null then
            for kv in Aliases
                if kv.value.indexOf(command) != null then
                    command = kv.key
                    break
                end if
            end for

            if Commands.indexes.indexOf(command) == null then
                Console.error("Sorry! No such command available! (=0_0=)")
                Console.error("See <i>help</i> to get some!")
                continue
            end if
        end if

        arguments = []
        for part in parts
            arguments.push(part.to_int)
        end for
        command = Commands[command]
        command(arguments)
    end while
end function


Conditions.arguments = function(arguments, count)
    if arguments.len == count then return
    Console.error("Incorrect arguments count! (x^x)")
    Console.cmdloop
end function

Conditions.argumentsMoreThan = function(arguments, count)
    if arguments.len <= count then Conditions.arguments(arguments, -1)
end function

Conditions.argumentsFewerThan = function(arguments, count)
    if arguments.len >= count then Conditions.arguments(arguments, -1)
end function

Conditions.host = function
    if not Intrinsics.isConnectionRemote then return
    Console.error("I need to be run on host!")
    Console.cmdloop
end function

Conditions.remote = function
    if Intrinsics.isConnectionRemote then return
    Console.error("I need to be run on a remote connection!")
    Console.cmdloop
end function

Conditions.shell = function(preciseTypes=null)
    if Intrinsics.shell then
        if not preciseTypes then return
        if preciseTypes.indexOf(typeof(Intrinsics.shell)) != null then return
    end if
    if preciseTypes then
        Console.error("I need one of these: "+str(preciseTypes)+" !")
    else
        Console.error("I need a shell!")
    end if
    Console.cmdloop
end function

Conditions.computer = function
    if Intrinsics.computer then return
    Console.error("I am a computer addict!")
    Console.cmdloop
end function

Conditions.network = function
    if get_shell.host_computer.is_network_active then return
    Console.error("I want network connection!")
    Console.cmdloop
end function

Conditions.crypto = function
    if Libs.indexes.indexOf("crypto") != null then return
    Console.error("No crypto library!")
    Console.cmdloop
end function

Conditions.apt = function
    if Libs.indexes.indexOf("apt") != null then return
    Console.error("No apt library!")
    Console.cmdloop
end function

Conditions.metaxploit = function
    if Libs.indexes.indexOf("metaxploit") != null then return
    Console.error("No metaxploit library!")
    Console.cmdloop
end function

Conditions.blockchain = function
    if Libs.indexes.indexOf("blockchain") != null then return
    Console.error("No blockchain library!")
    Console.cmdloop
end function

// 
// Add session to the Sessions[]
// Overwrites session if it already exists
ISessions.add = function(intrinsics)
    ISessions._preprocess

    session = ISessions.createSession(intrinsics)

    if not session.Intrinsics.isConnectionRemote then
        hostSession = deepCopy(Vars.hostSession)
        if hostSession.name.split(" ")[1:] == session.name.split(" ")[1:] then
            Vars.hostSession = deepCopy(session)
            return
        end if
        hostSession.Intrinsics.isConnectionRemote = true
        ISessions.add(hostSession.Intrinsics)
        Vars.hostSession = deepCopy(session)
        return
    end if

    index = null
    lookup = -1
    for oldSession in Sessions
        lookup = lookup + 1
        if oldSession.name != session.name then continue
        index = lookup
        break
    end for
    if index == null then
        Sessions.push(session)
    else
        Sessions[index] = session
    end if
end function

ISessions.delete = function(id)
    ISessions._preprocess

    sessions = [Vars.hostSession] + Sessions
    if id < 2 or id > sessions.len then return false
    Sessions.remove(id-1 - 1)
    return true
end function

ISessions.get = function(id)
    ISessions._preprocess

    sessions = [Vars.hostSession] + Sessions
    if id < 1 or id > sessions.len then return
    return deepCopy(sessions[id-1])
end function

// 
// Creates session object
// Returns following:
// session = [
//     "name": string,
//     "Intrinsics": map,
// ]
ISessions.createSession = function(intrinsics)
    object = "Host"
    pubAddr = intrinsics.publicAddress
    locAddr = intrinsics.localAddress
    port = intrinsics.port
    user = checkPermissions(intrinsics.file)
    
    if intrinsics.isConnectionRemote then
        if intrinsics.file then object = "File"
        if intrinsics.computer then object = "Computer"
        if intrinsics.shell then
            type = typeof(intrinsics.shell)
            if type == "shell" then
                object = "Shell"
            else if type == "ftpshell" then
                object = "FtpShell"
            else
                object = "UnknownShell"
            end if
        end if
    end if

    if not pubAddr then pubAddr = "-"
    if not locAddr then locAddr = "-"
    if port == null then port = "-"
    if not user then user = "-"

    session = {
        "name": [object,pubAddr,locAddr,port,user].join(" "),
        "Intrinsics": deepCopy(intrinsics),
    }

    return session
end function

ISessions._preprocess = function
    // 
    // Sorting sessions by username and object type
    userPredicate = function(iItem, jItem)
        priority = {
            "root": 2,
            "guest": 1,
        }
        iUser = iItem.name.split(" ")[4]
        jUser = jItem.name.split(" ")[4]
        if priority.indexes.indexOf(iUser) == null then priority[iUser] = rnd
        if priority.indexes.indexOf(jUser) == null then priority[jUser] = rnd
        return priority[iUser] < priority[jUser]
    end function
    objectPredicate = function(iItem, jItem)
        priority = {
            "Host": 4,
            "Shell": 3,
            "FtpShell": 2,
            "Computer": 1,
            "File": 0,
        }
        iObject = iItem.name.split(" ")[0]
        jObject = jItem.name.split(" ")[0]
        return priority[iObject] < priority[jObject]
    end function
    mergeSort(Sessions, @userPredicate)
    mergeSort(Sessions, @objectPredicate)
end function
